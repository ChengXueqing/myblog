# JavaScript基础

## 事件
### 事件产生与事件流
由用户操作web页面的行为触发，事件发生时会在元素节点与根节点之间按照特定的顺序传播，路径所经过的所有节点都会收到该事件，这个传播过程即DOM事件流。<br>
### 事件流的三个阶段
* 捕获阶段：事件对象从目标的祖先节点Window开始传播直至目标。
* 目标阶段：事件对象传递到事件目标。如果事件的type属性表明后面不会进行冒泡操作，那么事件到此就结束了。
* 冒泡阶段：事件对象以一个相反的方向进行传递，从目标开始，到Window对象结束。

**事件冒泡** 事件按照从最特定的事件目标到最不特定的事件目标(document对象)的顺序触发。
**事件捕获** 事件按照从最不特定的事件目标到最特定的事件目标(document对象)的顺序。
```
<!DOCTYPE html>
<html>
    <head>
        <meta charset="UTF-8">
        <title></title>
        <style type="text/css">
            #outer{
                width: 200px;
                height: 200px;
                background: red;
            }
            #inner{
                width: 100px;
                height: 100px;
                background: blue;
            }
        </style>
    </head>
    <body>
        <div id="outer">
            <div id="inner"></div>
        </div>
        <script type="text/javascript">
            var outer = document.getElementById("outer");
            var inner = document.getElementById("inner");
            document.onclick = function(){
                console.log("document");
            }
            inner.onclick = function(e){
                var evt = e || event;
                console.log("inner");
            }
            outer.onclick = function(e){
                var evt = e || event;
                console.log("outer");
            }
        </script>
    </body>
</html>

```
**阻止事件冒泡** 不同浏览器对阻止冒泡的写法存在兼容问题,在ie浏览器中阻止冒泡的方法是window.event.cancelBubble=true而在谷歌,火狐等浏览器的方法则是e.stopPropagation()
阻止事件在DOM中继续传播，即取消进一步的事件捕获或冒泡，防止再触发定义在别的节点上的监听函数，但是不包括在当前节点上新定义的事件监听函数。
```
outer.onclick = function(e){
    var evt = e || event;
    console.log("outer");
    if(evt.stopPropagation){
        evt.stopPropagation();
    }else{
        evt.cancelBubble = true;
    }
}
```
### 事件委托
利用事件冒泡的特性，将里层的事件委托给外层事件，根据event对象的属性进行事件委托，改善性能。
使用事件委托能够避免对特定的每个节点添加事件监听器；事件监听器是被添加到它们的父元素上。事件监听器会分析从子元素冒泡上来的事件，找到是哪个子元素的事件。
举个例子，点击更多添加li,且点击每个li都输出aa,点击其他地方不显示。

_参考资料：https://www.jianshu.com/p/38997c83b017_

## 框架

### 写 React/Vue 项目时为什么要在列表组件中写 key？作用是什么？
答：Vue 和 React 都是采用 diff 算法来对比新旧虚拟节点，从而更新节点。key 是给每一个 vnode 的唯一 id,可以依靠 key，更准确，更快的拿到 oldVnode 中对应的 vnode 节点。
- 更准确
  避免就地复用，在sameNode函数 a.key === b.key对比可以避免就地复用的情况，所以会更加准确。
- 更快
  利用key的唯一性生成map对象来获取对应节点，比遍历方式更快。


### Vue3和Vue2相比有哪些新特性？

静态提升、靶向更新。
虽然，对于面试常问的 diff 过程在一定程度上是减少了对 DOM 的直接操作。但是，这个减少是有一定成本的。因为，如果是复杂应用，那么就会存在父子关系非常复杂的 VNode，而这也就是 diff 的痛点，它会不断地递归调用 patchVNode，不断堆叠而成的几毫秒，最终就会造成 VNode 更新缓慢。
也因此，这也是为什么我们所看到的大型应用诸如阿里云之类的采用的是基于「React」的技术栈的原因之一。所以，「Vue3」也是痛改前非，重写了整个 Compiler 过程，提出了静态提升、靶向更新等优化点，来提高 patchVNode 过程。

静态更新：在Vue3中使用了静态提升后，对于不参与更新的元素，只会被创建一次，在渲染时直接复用即可
